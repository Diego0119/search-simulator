<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>search-simulator: src/inverted_index.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">search-simulator
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">inverted_index.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Archivo que contiene las funciones del índice invertido.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="graph_8h_source.html">graph.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="inverted__index_8h_source.html">inverted_index.h</a>&quot;</code><br />
</div>
<p><a href="inverted__index_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a054f8c4c40d35263099ce511744fef5a" id="r_a054f8c4c40d35263099ce511744fef5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054f8c4c40d35263099ce511744fef5a">create_new_node</a> (char *word)</td></tr>
<tr class="memdesc:a054f8c4c40d35263099ce511744fef5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Incluye la definición de las estructuras y funciones del índice invertido.  <br /></td></tr>
<tr class="separator:a054f8c4c40d35263099ce511744fef5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5eedac977ab2452507dbb9a7bb88df9" id="r_ac5eedac977ab2452507dbb9a7bb88df9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5eedac977ab2452507dbb9a7bb88df9">add_document</a> (<a class="el" href="structInvertedIndex.html">InvertedIndex</a> **hash_table, int doc_id, char *word)</td></tr>
<tr class="memdesc:ac5eedac977ab2452507dbb9a7bb88df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un documento al índice invertido, asociándolo con una palabra específica.  <br /></td></tr>
<tr class="separator:ac5eedac977ab2452507dbb9a7bb88df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a7253925df4ca184eeac9fbed8b6a3" id="r_a74a7253925df4ca184eeac9fbed8b6a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74a7253925df4ca184eeac9fbed8b6a3">is_stopword</a> (char *token)</td></tr>
<tr class="memdesc:a74a7253925df4ca184eeac9fbed8b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica si un token es una palabra irrelevante (stopword) que debe ignorarse en el índice.  <br /></td></tr>
<tr class="separator:a74a7253925df4ca184eeac9fbed8b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43037f50a965f75d13c1c79470a3c1f" id="r_aa43037f50a965f75d13c1c79470a3c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43037f50a965f75d13c1c79470a3c1f">tokenize_text</a> (char *text, int doc_id, <a class="el" href="structInvertedIndex.html">InvertedIndex</a> **index)</td></tr>
<tr class="memdesc:aa43037f50a965f75d13c1c79470a3c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokeniza el texto de entrada, eliminando puntuación y stopwords, e indexa cada palabra.  <br /></td></tr>
<tr class="separator:aa43037f50a965f75d13c1c79470a3c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd6888286a2f08c29ef53e02f40fde9" id="r_a0dd6888286a2f08c29ef53e02f40fde9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd6888286a2f08c29ef53e02f40fde9">print_inverted_index</a> (<a class="el" href="structInvertedIndex.html">InvertedIndex</a> **index)</td></tr>
<tr class="memdesc:a0dd6888286a2f08c29ef53e02f40fde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imprime el índice invertido mostrando cada palabra y los documentos asociados.  <br /></td></tr>
<tr class="separator:a0dd6888286a2f08c29ef53e02f40fde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897c98d07f8e56920aef2803e175cbd8" id="r_a897c98d07f8e56920aef2803e175cbd8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a897c98d07f8e56920aef2803e175cbd8">hash_function</a> (char *word)</td></tr>
<tr class="memdesc:a897c98d07f8e56920aef2803e175cbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Función hash para obtener un índice basado en el valor ASCII de los caracteres de una palabra.  <br /></td></tr>
<tr class="separator:a897c98d07f8e56920aef2803e175cbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66d55e651735ee8262e7a6de2d5b05" id="r_a4f66d55e651735ee8262e7a6de2d5b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structNode.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f66d55e651735ee8262e7a6de2d5b05">search_word</a> (<a class="el" href="structInvertedIndex.html">InvertedIndex</a> **hash_table, char *word)</td></tr>
<tr class="memdesc:a4f66d55e651735ee8262e7a6de2d5b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca una palabra en el índice invertido y retorna la lista de documentos asociados.  <br /></td></tr>
<tr class="separator:a4f66d55e651735ee8262e7a6de2d5b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed64c2ea34cfe6b9b40f4e164b81e8fb" id="r_aed64c2ea34cfe6b9b40f4e164b81e8fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed64c2ea34cfe6b9b40f4e164b81e8fb">print_search_word_with_pagerank</a> (<a class="el" href="structInvertedIndex.html">InvertedIndex</a> **index, char *word_to_search, <a class="el" href="structGraph.html">Graph</a> *graph, double *pagerank)</td></tr>
<tr class="memdesc:aed64c2ea34cfe6b9b40f4e164b81e8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imprime los documentos y la frecuencia de aparición de una palabra junto con el PageRank.  <br /></td></tr>
<tr class="separator:aed64c2ea34cfe6b9b40f4e164b81e8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321feae1c468f2511ae1ac93b2709c52" id="r_a321feae1c468f2511ae1ac93b2709c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321feae1c468f2511ae1ac93b2709c52">build_index</a> (<a class="el" href="structGraph.html">Graph</a> *graph, <a class="el" href="structInvertedIndex.html">InvertedIndex</a> **index)</td></tr>
<tr class="memdesc:a321feae1c468f2511ae1ac93b2709c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee los archivos asociados al grafo y crea el índice invertido.  <br /></td></tr>
<tr class="separator:a321feae1c468f2511ae1ac93b2709c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd40fec44adaa6401c2609cced5b0479" id="r_afd40fec44adaa6401c2609cced5b0479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd40fec44adaa6401c2609cced5b0479">release_inverted_index</a> (<a class="el" href="structInvertedIndex.html">InvertedIndex</a> **hash_table)</td></tr>
<tr class="memdesc:afd40fec44adaa6401c2609cced5b0479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libera la memoria del índice invertido y los nodos de documentos asociados.  <br /></td></tr>
<tr class="separator:afd40fec44adaa6401c2609cced5b0479"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Archivo que contiene las funciones del índice invertido. </p>
<dl class="section date"><dt>Date</dt><dd>18-11-2024 </dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Miguel Loaiza, Diego Sanhueza, Miguel Maripillan y Felipe Cárcamo </dd></dl>
<p>Contiene la implementación de las funciones que crean y manipulan el índice invertido. </p>

<p class="definition">Definition in file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac5eedac977ab2452507dbb9a7bb88df9" name="ac5eedac977ab2452507dbb9a7bb88df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5eedac977ab2452507dbb9a7bb88df9">&#9670;&#160;</a></span>add_document()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_document </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>doc_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Agrega un documento al índice invertido, asociándolo con una palabra específica. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>Tabla hash que contiene el índice invertido. </td></tr>
    <tr><td class="paramname">doc_id</td><td>ID del documento donde aparece la palabra. </td></tr>
    <tr><td class="paramname">word</td><td>Palabra que se indexará. </td></tr>
  </table>
  </dd>
</dl>
<p>Calcula el índice en la tabla hash para la palabra. Busca la palabra en la lista enlazada correspondiente al índice. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = <a class="code hl_function" href="#a897c98d07f8e56920aef2803e175cbd8">hash_function</a>(word);</div>
<div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *current = hash_table[index];</div>
<div class="line"><span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(current-&gt;word, word) == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// La palabra ya está en el índice; agrega el documento.</span></div>
<div class="line">        <a class="code hl_struct" href="structNode.html">Node</a> *new_doc = (<a class="code hl_struct" href="structNode.html">Node</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structNode.html">Node</a>));</div>
<div class="line">        new_doc-&gt;doc_id = doc_id;</div>
<div class="line">        new_doc-&gt;next = current-&gt;docs_list;</div>
<div class="line">        current-&gt;docs_list = new_doc;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    current = current-&gt;next;</div>
<div class="line">}</div>
<div class="ttc" id="ainverted__index_8c_html_a897c98d07f8e56920aef2803e175cbd8"><div class="ttname"><a href="#a897c98d07f8e56920aef2803e175cbd8">hash_function</a></div><div class="ttdeci">unsigned int hash_function(char *word)</div><div class="ttdoc">Función hash para obtener un índice basado en el valor ASCII de los caracteres de una palabra.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00330">inverted_index.c:330</a></div></div>
<div class="ttc" id="astructInvertedIndex_html"><div class="ttname"><a href="structInvertedIndex.html">InvertedIndex</a></div><div class="ttdoc">&lt; Incluye la definición de las estructuras y funciones del grafo.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8h_source.html#l00026">inverted_index.h:27</a></div></div>
<div class="ttc" id="astructNode_html"><div class="ttname"><a href="structNode.html">Node</a></div><div class="ttdoc">Estrucutra de un nodo.</div><div class="ttdef"><b>Definition</b> <a href="graph_8h_source.html#l00069">graph.h:70</a></div></div>
</div><!-- fragment --><p>Si la palabra no está en el índice, crea un nuevo nodo y la agrega al índice. También asigna memoria para un nodo que representa el documento. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *new_node = <a class="code hl_function" href="#a054f8c4c40d35263099ce511744fef5a">create_new_node</a>(word);</div>
<div class="line">new_node-&gt;next = hash_table[index];</div>
<div class="line">hash_table[index] = new_node;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structNode.html">Node</a> *new_doc = (<a class="code hl_struct" href="structNode.html">Node</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structNode.html">Node</a>));</div>
<div class="line"><span class="keywordflow">if</span> (new_doc == NULL)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error al asignar memoria para nuevo documento\n&quot;</span>);</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
<div class="line">new_doc-&gt;doc_id = doc_id;</div>
<div class="line">new_doc-&gt;next = NULL;</div>
<div class="line">new_node-&gt;docs_list = new_doc;</div>
<div class="ttc" id="ainverted__index_8c_html_a054f8c4c40d35263099ce511744fef5a"><div class="ttname"><a href="#a054f8c4c40d35263099ce511744fef5a">create_new_node</a></div><div class="ttdeci">InvertedIndex * create_new_node(char *word)</div><div class="ttdoc">&lt; Incluye la definición de las estructuras y funciones del índice invertido.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00017">inverted_index.c:17</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00059">59</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a321feae1c468f2511ae1ac93b2709c52" name="a321feae1c468f2511ae1ac93b2709c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321feae1c468f2511ae1ac93b2709c52">&#9670;&#160;</a></span>build_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void build_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGraph.html">Graph</a> *</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee los archivos asociados al grafo y crea el índice invertido. </p>
<p>Lee los archivos que se encuentran guardados en el grafo y crea el índice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>Grafo que contiene los datos de los documentos. </td></tr>
    <tr><td class="paramname">index</td><td>Tabla hash que contiene el índice invertido. </td></tr>
  </table>
  </dd>
</dl>
<p>Itera sobre los documentos identificados en el grafo. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; graph-&gt;total_docs; i++)</div>
<div class="line">{</div>
<div class="line">    FILE *file = fopen(graph-&gt;mapping_docs[i].name, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (file == NULL)</div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;No se pudo abrir el archivo %s\n&quot;</span>, graph-&gt;mapping_docs[i].name);</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Intenta abrir el archivo correspondiente al documento. Si el archivo no puede ser abierto, muestra un error y pasa al siguiente documento. </p><div class="fragment"><div class="line">FILE *file = fopen(graph-&gt;mapping_docs[i].name, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (file == NULL)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;No se pudo abrir el archivo %s\n&quot;</span>, graph-&gt;mapping_docs[i].name);</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Define un buffer para leer cada línea del archivo. </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> buffer[1024];</div>
<div class="line"><span class="keywordflow">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file))</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="#aa43037f50a965f75d13c1c79470a3c1f">tokenize_text</a>(buffer, graph-&gt;mapping_docs[i].doc_id, index);</div>
<div class="line">}</div>
<div class="ttc" id="ainverted__index_8c_html_aa43037f50a965f75d13c1c79470a3c1f"><div class="ttname"><a href="#aa43037f50a965f75d13c1c79470a3c1f">tokenize_text</a></div><div class="ttdeci">void tokenize_text(char *text, int doc_id, InvertedIndex **index)</div><div class="ttdoc">Tokeniza el texto de entrada, eliminando puntuación y stopwords, e indexa cada palabra.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00207">inverted_index.c:207</a></div></div>
</div><!-- fragment --><p>Procesa cada línea del archivo y la pasa a la función tokenize_text, que procesa el texto y lo agrega al índice invertido. </p><div class="fragment"><div class="line"><a class="code hl_function" href="#aa43037f50a965f75d13c1c79470a3c1f">tokenize_text</a>(buffer, graph-&gt;mapping_docs[i].doc_id, index);</div>
</div><!-- fragment --><p>Cierra el archivo una vez que ha terminado de procesarlo. </p><div class="fragment"><div class="line">fclose(file);</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00590">590</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a054f8c4c40d35263099ce511744fef5a" name="a054f8c4c40d35263099ce511744fef5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054f8c4c40d35263099ce511744fef5a">&#9670;&#160;</a></span>create_new_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> * create_new_node </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Incluye la definición de las estructuras y funciones del índice invertido. </p>
<p>Crea un nuevo nodo en el índice invertido para una palabra específica.</p>
<p>&lt; Incluye la definición de las estructuras y funciones del grafo.</p>
<p>Crea un nuevo nodo en el índice invertido para una palabra específica. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>La palabra a agregar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Un puntero al nuevo nodo creado. </dd></dl>
<p>Asigna memoria para el nuevo nodo del índice invertido. Si la asignación falla, se imprime un mensaje de error y el programa termina. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *new_node = (<a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *)malloc(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a>));</div>
<div class="line"><span class="keywordflow">if</span> (new_node == NULL)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error al asignar memoria\n&quot;</span>);</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Copia la palabra en el nodo y establece la lista de documentos y el puntero siguiente a NULL. Inicialmente, no hay documentos asociados con esta palabra, y el puntero al siguiente nodo también es NULL. </p><div class="fragment"><div class="line">strcpy(new_node-&gt;word, word);</div>
<div class="line">new_node-&gt;docs_list = NULL;</div>
<div class="line">new_node-&gt;next = NULL;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00017">17</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a897c98d07f8e56920aef2803e175cbd8" name="a897c98d07f8e56920aef2803e175cbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897c98d07f8e56920aef2803e175cbd8">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hash_function </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Función hash para obtener un índice basado en el valor ASCII de los caracteres de una palabra. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>Palabra a procesar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valor hash de la palabra. </dd></dl>
<p>Inicializa el valor hash en cero. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash = 0;</div>
</div><!-- fragment --><p>Recorre cada carácter en la palabra y actualiza el valor hash. El hash se calcula multiplicando el valor anterior por 31 y sumando el código ASCII de cada carácter. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; word[i] != <span class="charliteral">&#39;\0&#39;</span>; i++)</div>
<div class="line">    hash = (hash * 31) + word[i];</div>
</div><!-- fragment --><p>Limita el valor hash por el tamaño máximo de la tabla hash. </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> hash % HASH_TABLE_SIZE;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00330">330</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a74a7253925df4ca184eeac9fbed8b6a3" name="a74a7253925df4ca184eeac9fbed8b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a7253925df4ca184eeac9fbed8b6a3">&#9670;&#160;</a></span>is_stopword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_stopword </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifica si un token es una palabra irrelevante (stopword) que debe ignorarse en el índice. </p>
<p>Convierte todo el texto a minúsculas y reemplaza caracteres de puntuación por espacios.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>El token a analizar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el token es una stopword, <code>false</code> en caso contrario. </dd></dl>
<p>Lista de palabras consideradas como stopwords. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *stopwords[] = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;o&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;link&quot;</span>};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> num_stopwords = <span class="keyword">sizeof</span>(stopwords) / <span class="keyword">sizeof</span>(stopwords[0]);</div>
</div><!-- fragment --><p>Convierte el token a minúsculas para evitar problemas con mayúsculas/minúsculas. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; token[i]; i++)</div>
<div class="line">{</div>
<div class="line">    token[i] = tolower((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)token[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compara el token con las stopwords. Si el token es una stopword, devuelve <code>true</code>. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_stopwords; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(token, stopwords[i]) == 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Verificación del patrón "docN", donde N es un número. Si el token comienza con "doc" seguido de un número, devuelve <code>true</code>. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (strncmp(token, <span class="stringliteral">&quot;doc&quot;</span>, 3) == 0 &amp;&amp; isdigit(token[3]))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00137">137</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a0dd6888286a2f08c29ef53e02f40fde9" name="a0dd6888286a2f08c29ef53e02f40fde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd6888286a2f08c29ef53e02f40fde9">&#9670;&#160;</a></span>print_inverted_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_inverted_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imprime el índice invertido mostrando cada palabra y los documentos asociados. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Tabla hash que contiene el índice invertido. </td></tr>
  </table>
  </dd>
</dl>
<p>Recorre la tabla hash y muestra las palabras y sus documentos asociados. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HASH_TABLE_SIZE; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (index[i] != NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *current = index[i];</div>
<div class="line">        <span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">        {</div>
<div class="line">            fprintf(stdout, <span class="stringliteral">&quot;Palabra: %s - Documentos: &quot;</span>, current-&gt;word);</div>
<div class="line">            <a class="code hl_struct" href="structNode.html">Node</a> *doc_node = current-&gt;docs_list;</div>
<div class="line">            <span class="keywordflow">while</span> (doc_node != NULL)</div>
<div class="line">            {</div>
<div class="line">                fprintf(stdout, <span class="stringliteral">&quot;%d &quot;</span>, doc_node-&gt;doc_id);</div>
<div class="line">                doc_node = doc_node-&gt;next;</div>
<div class="line">            }</div>
<div class="line">            fprintf(stdout, <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">            current = current-&gt;next;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00275">275</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="aed64c2ea34cfe6b9b40f4e164b81e8fb" name="aed64c2ea34cfe6b9b40f4e164b81e8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed64c2ea34cfe6b9b40f4e164b81e8fb">&#9670;&#160;</a></span>print_search_word_with_pagerank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_search_word_with_pagerank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word_to_search</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGraph.html">Graph</a> *</td>          <td class="paramname"><span class="paramname"><em>graph</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>pagerank</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imprime los documentos y la frecuencia de aparición de una palabra junto con el PageRank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Tabla hash que contiene el índice invertido. </td></tr>
    <tr><td class="paramname">word_to_search</td><td>Palabra a buscar en el índice. </td></tr>
    <tr><td class="paramname">graph</td><td>Grafo que contiene los documentos. </td></tr>
    <tr><td class="paramname">pagerank</td><td>Arreglo de valores de PageRank. </td></tr>
  </table>
  </dd>
</dl>
<p>Verifica que los parámetros no sean nulos. Si alguno lo es, imprime un mensaje de error y retorna. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!index || !word_to_search || !graph || !pagerank)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Error: Parámetros nulos pasados a la función.\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Busca la palabra en el índice invertido. Si no se encuentra, muestra un mensaje y retorna. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structNode.html">Node</a> *results = <a class="code hl_function" href="#a4f66d55e651735ee8262e7a6de2d5b05">search_word</a>(index, word_to_search);</div>
<div class="line"><span class="keywordflow">if</span> (!results)</div>
<div class="line">{</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;Palabra &#39;%s&#39; no encontrada.\n&quot;</span>, word_to_search);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="ainverted__index_8c_html_a4f66d55e651735ee8262e7a6de2d5b05"><div class="ttname"><a href="#a4f66d55e651735ee8262e7a6de2d5b05">search_word</a></div><div class="ttdeci">Node * search_word(InvertedIndex **hash_table, char *word)</div><div class="ttdoc">Busca una palabra en el índice invertido y retorna la lista de documentos asociados.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00366">inverted_index.c:366</a></div></div>
</div><!-- fragment --><p>Imprime un mensaje indicando que la palabra se ha encontrado en documentos e inicializa un arreglo para contar la frecuencia de la palabra en cada documento. </p><div class="fragment"><div class="line">fprintf(stdout, <span class="stringliteral">&quot;\nLa palabra &#39;%s&#39; se encuentra en los siguientes documentos:\n\n&quot;</span>, word_to_search);</div>
<div class="line"><span class="keywordtype">int</span> num_docs = graph-&gt;total_docs;</div>
<div class="line"><span class="keywordtype">int</span> doc_count[num_docs + 1];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= num_docs; i++)</div>
<div class="line">    doc_count[i] = 0;</div>
</div><!-- fragment --><p>Recorre la lista de resultados para contar la frecuencia de la palabra en cada documento. Considera solo documentos con identificadores válidos. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structNode.html">Node</a> *current = results;</div>
<div class="line"><span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (current-&gt;doc_id &gt; 0 &amp;&amp; current-&gt;doc_id &lt;= num_docs)</div>
<div class="line">    {</div>
<div class="line">        doc_count[current-&gt;doc_id]++;</div>
<div class="line">    }</div>
<div class="line">    current = current-&gt;next;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Crea un arreglo que contiene todos los documentos. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> all_docs[num_docs];</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= num_docs; i++)</div>
<div class="line">{</div>
<div class="line">    all_docs[i - 1] = i; </div>
<div class="line">}</div>
</div><!-- fragment --><p>Ordena todos los documentos por PageRank en orden descendente. Utiliza un algoritmo de ordenamiento burbuja (bubble sort). </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_docs - 1; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i + 1; j &lt; num_docs; j++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> doc_i = all_docs[i];</div>
<div class="line">        <span class="keywordtype">int</span> doc_j = all_docs[j];</div>
<div class="line">        <span class="keywordflow">if</span> (pagerank[doc_i - 1] &lt; pagerank[doc_j - 1])</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">int</span> temp = all_docs[i];</div>
<div class="line">            all_docs[i] = all_docs[j];</div>
<div class="line">            all_docs[j] = temp;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Imprime solo los documentos donde la palabra fue encontrada (doc_count &gt; 0), junto con la frecuencia y el PageRank. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_docs; i++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> doc_id = all_docs[i];</div>
<div class="line">    <span class="keywordflow">if</span> (doc_count[doc_id] &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Doc%d: %d veces   -   PageRank = %.6f\n&quot;</span>, doc_id, doc_count[doc_id], pagerank[doc_id - 1]);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00429">429</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="afd40fec44adaa6401c2609cced5b0479" name="afd40fec44adaa6401c2609cced5b0479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd40fec44adaa6401c2609cced5b0479">&#9670;&#160;</a></span>release_inverted_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void release_inverted_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Libera la memoria del índice invertido y los nodos de documentos asociados. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>Tabla hash que contiene el índice invertido. </td></tr>
  </table>
  </dd>
</dl>
<p>Verifica si la tabla hash es nula y retorna si es el caso. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (hash_table == NULL)</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
</div><!-- fragment --><p>Recorre cada índice en la tabla hash. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; HASH_TABLE_SIZE; i++)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *current = hash_table[i];</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Procesa la lista de palabras asociada a cada índice en la tabla hash. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *current = hash_table[i];</div>
<div class="line"><span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structNode.html">Node</a> *doc_node = current-&gt;docs_list;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Libera la memoria de cada palabra y su lista de documentos. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structNode.html">Node</a> *doc_node = current-&gt;docs_list;</div>
<div class="line">    <span class="keywordflow">while</span> (doc_node != NULL)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_struct" href="structNode.html">Node</a> *temp_doc_node = doc_node;</div>
<div class="line">        doc_node = doc_node-&gt;next;</div>
<div class="line">        free(temp_doc_node);</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *temp = current;</div>
<div class="line">    current = current-&gt;next;</div>
<div class="line">    free(temp);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Libera cada nodo de documento. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structNode.html">Node</a> *temp_doc_node = doc_node;</div>
<div class="line">doc_node = doc_node-&gt;next;</div>
<div class="line">free(temp_doc_node);</div>
</div><!-- fragment --><p>Libera el nodo de la palabra. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *temp = current;</div>
<div class="line">current = current-&gt;next;</div>
<div class="line">free(temp);</div>
</div><!-- fragment --><p>Establece el índice en la tabla hash como NULL después de liberar su memoria. </p><div class="fragment"><div class="line">hash_table[i] = NULL;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00664">664</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="a4f66d55e651735ee8262e7a6de2d5b05" name="a4f66d55e651735ee8262e7a6de2d5b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f66d55e651735ee8262e7a6de2d5b05">&#9670;&#160;</a></span>search_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structNode.html">Node</a> * search_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busca una palabra en el índice invertido y retorna la lista de documentos asociados. </p>
<p>Busca una palabra en el índice invertido.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>Tabla hash que contiene el índice invertido. </td></tr>
    <tr><td class="paramname">word</td><td>Palabra que se busca en el índice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lista de nodos de documentos donde aparece la palabra, o <code>NULL</code> si no se encuentra. </dd></dl>
<p>Convierte la palabra a minúsculas para una comparación uniforme. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; word[i]; i++)</div>
<div class="line">    word[i] = tolower(word[i]);</div>
</div><!-- fragment --><p>Obtiene el índice en la tabla hash utilizando la función hash. </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = <a class="code hl_function" href="#a897c98d07f8e56920aef2803e175cbd8">hash_function</a>(word);</div>
</div><!-- fragment --><p>Inicia la búsqueda en la lista de nodos de la tabla hash. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structInvertedIndex.html">InvertedIndex</a> *current = hash_table[index];</div>
</div><!-- fragment --><p>Recorre los nodos en busca de la palabra, comparando cada nodo con la palabra buscada. Si se encuentra, se retorna la lista de documentos asociados. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (current != NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(current-&gt;word, word) == 0)</div>
<div class="line">        <span class="keywordflow">return</span> current-&gt;docs_list;</div>
<div class="line">    current = current-&gt;next;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Retorna NULL si la palabra no se encuentra en la tabla hash. </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> NULL;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00366">366</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
<a id="aa43037f50a965f75d13c1c79470a3c1f" name="aa43037f50a965f75d13c1c79470a3c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43037f50a965f75d13c1c79470a3c1f">&#9670;&#160;</a></span>tokenize_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tokenize_text </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>doc_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInvertedIndex.html">InvertedIndex</a> **</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokeniza el texto de entrada, eliminando puntuación y stopwords, e indexa cada palabra. </p>
<p>Tokeniza el texto y agrega las palabras al índice invertido.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Texto de entrada que será tokenizado. </td></tr>
    <tr><td class="paramname">doc_id</td><td>ID del documento al que pertenece el texto. </td></tr>
    <tr><td class="paramname">index</td><td>Tabla hash que contiene el índice invertido. </td></tr>
  </table>
  </dd>
</dl>
<p>Convierte todo el texto a minúsculas. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; text[i]; i++)</div>
<div class="line">    text[i] = tolower(text[i]);</div>
</div><!-- fragment --><p>Reemplaza caracteres de puntuación por espacios. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; text[i]; i++)</div>
<div class="line">    <span class="keywordflow">if</span> (ispunct(text[i]))</div>
<div class="line">        text[i] = <span class="charliteral">&#39; &#39;</span>;</div>
</div><!-- fragment --><p>Separa el texto en palabras utilizando el espacio como delimitador. </p><div class="fragment"><div class="line">token = strtok(text, <span class="stringliteral">&quot; &quot;</span>);</div>
</div><!-- fragment --><p>Procesa cada token. </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (token != NULL)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (strlen(token) &gt;= MAX_WORD_SIZE)</div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;La palabra es muy larga\n&quot;</span>);</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="#a74a7253925df4ca184eeac9fbed8b6a3">is_stopword</a>(token))</div>
<div class="line">        <a class="code hl_function" href="#ac5eedac977ab2452507dbb9a7bb88df9">add_document</a>(index, doc_id, token);</div>
<div class="line">    token = strtok(NULL, <span class="stringliteral">&quot; &quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="ainverted__index_8c_html_a74a7253925df4ca184eeac9fbed8b6a3"><div class="ttname"><a href="#a74a7253925df4ca184eeac9fbed8b6a3">is_stopword</a></div><div class="ttdeci">bool is_stopword(char *token)</div><div class="ttdoc">Verifica si un token es una palabra irrelevante (stopword) que debe ignorarse en el índice.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00137">inverted_index.c:137</a></div></div>
<div class="ttc" id="ainverted__index_8c_html_ac5eedac977ab2452507dbb9a7bb88df9"><div class="ttname"><a href="#ac5eedac977ab2452507dbb9a7bb88df9">add_document</a></div><div class="ttdeci">void add_document(InvertedIndex **hash_table, int doc_id, char *word)</div><div class="ttdoc">Agrega un documento al índice invertido, asociándolo con una palabra específica.</div><div class="ttdef"><b>Definition</b> <a href="inverted__index_8c_source.html#l00059">inverted_index.c:59</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="inverted__index_8c_source.html#l00207">207</a> of file <a class="el" href="inverted__index_8c_source.html">inverted_index.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
